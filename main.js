/*
GENERATED BY ESBUILD
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => IMEOrchestrator
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var DEFAULTS = {
  macos: {
    pathToIM: "/opt/homebrew/bin",
    cmdOnInsertEnter: "macism im.rime.inputmethod.Squirrel.Hans",
    // 示例：B
    cmdOnInsertLeave: "macism com.apple.keylayout.ABC",
    // 示例：A
    cmdOnInsertEnterMathEnter: "macism com.apple.keylayout.ABC",
    // A
    cmdOnInsertEnterMathLeave: "macism im.rime.inputmethod.Squirrel.Hans"
    // B
  },
  windows: {
    pathToIM: "%USERPROFILE%\\AppData\\Local\\bin",
    cmdOnInsertEnter: "im-select.exe 2052",
    // 示例：B（中文）
    cmdOnInsertLeave: "im-select.exe 1033",
    cmdOnInsertEnterMathEnter: "im-select.exe 1033",
    cmdOnInsertEnterMathLeave: "im-select.exe 2052"
  },
  linux: {
    pathToIM: "/usr/bin",
    cmdOnInsertEnter: "ibus engine cn.some-ime",
    // 示例：B
    cmdOnInsertLeave: "ibus engine xkb:us::eng",
    cmdOnInsertEnterMathEnter: "ibus engine xkb:us::eng",
    cmdOnInsertEnterMathLeave: "ibus engine cn.some-ime"
  },
  statusBar: false,
  asyncExec: true
};
var IMEOrchestrator = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    // 运行时状态
    this.isInsert = false;
    // 当前是否在 Insert 模式
    this.inMath = false;
    // 光标是否在数学区域（仅在 Insert 内跟踪）
    this.prevVimMode = "normal";
    // 上一次 Vim 模式
    // 防止重复执行和竞态条件
    this.isExecutingCommand = false;
    // 是否正在执行输入法切换命令
    this.pendingCommand = null;
    // 待执行的命令
    this.hookedEditors = /* @__PURE__ */ new WeakSet();
    // —— 同目标命令去重（增加到 300ms 窗口以处理复杂场景）——
    this._lastCmd = "";
    this._lastAt = 0;
  }
  // 已经钩子的编辑器
  async onload() {
    await this.loadSettings();
    this.platform = process.platform === "darwin" ? "macos" : process.platform === "win32" ? "windows" : "linux";
    this.plat = this.settings[this.platform];
    this.extendPATH(this.plat.pathToIM);
    this.statusEl = this.addStatusBarItem();
    this.setStatus("");
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => this.hookVim()));
    this.registerEvent(this.app.workspace.on("file-open", () => this.hookVim()));
    this.hookVim();
    this.registerEditorExtension(
      import_view.EditorView.updateListener.of((update) => {
        if (!this.isInsert)
          return;
        if (!(update.docChanged || update.selectionSet))
          return;
        const nowInMath = this.isCursorInMath(update.view);
        if (nowInMath === this.inMath)
          return;
        this.inMath = nowInMath;
        if (this.inMath) {
          this.execMaybeAsync(this.plat.cmdOnInsertEnterMathEnter);
        } else {
          this.execMaybeAsync(this.plat.cmdOnInsertEnterMathLeave);
        }
      })
    );
    this.addSettingTab(new OrchestratorSettingTab(this.app, this));
  }
  onunload() {
  }
  // —— Vim 模式钩子 ——
  hookVim() {
    var _a, _b, _c;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const cm = (_c = (_b = (_a = view == null ? void 0 : view.sourceMode) == null ? void 0 : _a.cmEditor) == null ? void 0 : _b.cm) == null ? void 0 : _c.cm;
    if (!cm)
      return;
    if (this.hookedEditors.has(cm))
      return;
    cm.on("vim-mode-change", (modeObj) => {
      if (!modeObj)
        return;
      setTimeout(() => {
        this.handleVimModeChange(modeObj);
      }, 0);
    });
    this.hookedEditors.add(cm);
  }
  handleVimModeChange(modeObj) {
    const wasInsert = this.isInsert;
    this.isInsert = modeObj.mode === "insert";
    switch (modeObj.mode) {
      case "insert":
        if (!wasInsert) {
          this.onInsertEnter();
        }
        break;
      default:
        if (this.prevVimMode === "insert" && wasInsert) {
          this.onInsertLeave();
        }
        break;
    }
    this.prevVimMode = modeObj.mode;
  }
  // —— 数学块判定 ——
  isCursorInMath(view) {
    try {
      const state = view.state;
      const pos2 = state.selection.main.head;
      const tree = (0, import_language.syntaxTree)(state);
      let node = tree.resolveInner(pos2, -1);
      while (node) {
        const name = node.name.toLowerCase();
        if (name.includes("math")) {
          if (name.includes("math-end") && pos2 > node.to)
            return false;
          if (name.includes("math-begin") && pos2 < node.from)
            return false;
          return true;
        }
        node = node.parent;
      }
    } catch (_) {
    }
    const text = view.state.doc.toString();
    const pos = view.state.selection.main.head;
    let i = 0;
    while (i < text.length) {
      if (text[i] === "$") {
        if (i + 1 < text.length && text[i + 1] === "$") {
          const start = i;
          i += 2;
          let end = -1;
          while (i + 1 < text.length) {
            if (text[i] === "$" && text[i + 1] === "$") {
              end = i + 1;
              break;
            }
            i++;
          }
          if (end !== -1 && pos > start && pos <= end)
            return true;
          if (end === -1 && pos > start)
            return true;
          i = end !== -1 ? end + 1 : i;
        } else {
          const start = i;
          i++;
          let end = -1;
          while (i < text.length) {
            if (text[i] === "$" && (i + 1 >= text.length || text[i + 1] !== "$")) {
              end = i;
              break;
            }
            i++;
          }
          if (end !== -1 && pos > start && pos <= end)
            return true;
          if (end === -1 && pos > start)
            return true;
          i = end !== -1 ? end + 1 : i;
        }
      } else
        i++;
    }
    return false;
  }
  // —— 命令执行 ——
  extendPATH(extra) {
    const delim = process.platform === "win32" ? ";" : ":";
    process.env.PATH = `${process.env.PATH || ""}${delim}${extra}`;
  }
  injectIM(cmd, _im) {
    return cmd;
  }
  execMaybeAsync(command) {
    if (!command || command.trim() === "")
      return;
    if (this.isExecutingCommand) {
      this.pendingCommand = command;
      return;
    }
    if (!this._dedupe(command))
      return;
    this.isExecutingCommand = true;
    if (this.settings.asyncExec) {
      this.execAsync(command).catch(() => this.setStatus(`IME ERR`)).finally(() => this.handleCommandComplete());
    } else {
      try {
        this.execSync(command);
      } catch (e) {
        this.setStatus(`IME ERR`);
      } finally {
        this.handleCommandComplete();
      }
    }
  }
  handleCommandComplete() {
    this.isExecutingCommand = false;
    if (this.pendingCommand) {
      const cmd = this.pendingCommand;
      this.pendingCommand = null;
      setTimeout(() => this.execMaybeAsync(cmd), 10);
    }
  }
  _dedupe(cmd, windowMs = 300) {
    const now = Date.now();
    if (cmd && this._lastCmd === cmd && now - this._lastAt < windowMs) {
      return false;
    }
    this._lastCmd = cmd;
    this._lastAt = now;
    return true;
  }
  execAsync(command) {
    return new Promise((resolve, reject) => {
      (0, import_child_process.exec)(command, (error, stdout, _stderr) => {
        if (error) {
          reject(error);
          return;
        }
        resolve(stdout == null ? void 0 : stdout.toString().trim());
      });
    });
  }
  execSync(command) {
    try {
      return (0, import_child_process.execSync)(command, { encoding: "utf-8" });
    } catch (e) {
      return "";
    }
  }
  setStatus(msg) {
    var _a;
    if (!this.settings.statusBar)
      return;
    (_a = this.statusEl) == null ? void 0 : _a.setText(msg || "");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULTS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // —— 无缓存核心：进入/离开 Insert ——
  isOnInsertEnterEnabled() {
    return !!this.plat.cmdOnInsertEnter;
  }
  isOnInsertLeaveEnabled() {
    return !!this.plat.cmdOnInsertLeave;
  }
  onInsertEnter() {
    if (!this.isOnInsertEnterEnabled())
      return;
    setTimeout(() => {
      var _a, _b;
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      const cmView = (_b = (_a = view == null ? void 0 : view.editor) == null ? void 0 : _a.cm) == null ? void 0 : _b.view;
      if (cmView && this.isCursorInMath(cmView)) {
        this.inMath = true;
        return;
      }
      this.inMath = false;
      this.execMaybeAsync(this.plat.cmdOnInsertEnter);
    }, 50);
  }
  onInsertLeave() {
    if (!this.isOnInsertLeaveEnabled())
      return;
    this.inMath = false;
    this.execMaybeAsync(this.plat.cmdOnInsertLeave);
  }
};
var OrchestratorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "\u5E73\u53F0\u547D\u4EE4" });
    this.section(containerEl, "macOS", this.plugin.settings.macos);
    this.section(containerEl, "Windows", this.plugin.settings.windows);
    this.section(containerEl, "Linux", this.plugin.settings.linux);
    containerEl.createEl("h3", { text: "\u901A\u7528" });
    new import_obsidian.Setting(containerEl).setName("\u5F02\u6B65\u6267\u884C").setDesc("\u542F\u7528\u5B50\u8FDB\u7A0B\u5F02\u6B65\u6267\u884C\u547D\u4EE4").addToggle((t) => t.setValue(this.plugin.settings.asyncExec).onChange(async (v) => {
      this.plugin.settings.asyncExec = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u72B6\u6001\u680F\u63D0\u793A").setDesc("\u5728\u72B6\u6001\u680F\u663E\u793A\u9519\u8BEF\u63D0\u793A").addToggle((t) => t.setValue(this.plugin.settings.statusBar).onChange(async (v) => {
      this.plugin.settings.statusBar = v;
      await this.plugin.saveSettings();
    }));
  }
  section(containerEl, title, s) {
    containerEl.createEl("h4", { text: title });
    new import_obsidian.Setting(containerEl).setName("PATH to IM Tool").addText((t) => t.setValue(s.pathToIM).onChange(async (v) => {
      s.pathToIM = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("On InsertEnter").addText((t) => t.setValue(s.cmdOnInsertEnter).onChange(async (v) => {
      s.cmdOnInsertEnter = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("On InsertLeave").addText((t) => t.setValue(s.cmdOnInsertLeave).onChange(async (v) => {
      s.cmdOnInsertLeave = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("On InsertEnter MathEnter").addText((t) => t.setValue(s.cmdOnInsertEnterMathEnter).onChange(async (v) => {
      s.cmdOnInsertEnterMathEnter = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("On InsertEnter MathLeave").addText((t) => t.setValue(s.cmdOnInsertEnterMathLeave).onChange(async (v) => {
      s.cmdOnInsertEnterMathLeave = v;
      await this.plugin.saveSettings();
    }));
  }
};
